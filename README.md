# Фінальний проект: Основи алгоритмів

Цей репозиторій містить реалізацію 7 завдань з курсу "Основи алгоритмів", що охоплюють фундаментальні структури даних та алгоритми.

## Зміст

- [Завдання 1: Структури даних](#завдання-1-структури-даних)
- [Завдання 2: Рекурсія. Дерево Піфагора](#завдання-2-рекурсія-дерево-піфагора)
- [Завдання 3: Алгоритм Дейкстри](#завдання-3-алгоритм-дейкстри)
- [Завдання 4: Візуалізація бінарної купи](#завдання-4-візуалізація-бінарної-купи)
- [Завдання 5: Візуалізація обходу дерева](#завдання-5-візуалізація-обходу-дерева)
- [Завдання 6: Жадібні алгоритми та динамічне програмування](#завдання-6-жадібні-алгоритми-та-динамічне-програмування)
- [Завдання 7: Метод Монте-Карло](#завдання-7-метод-монте-карло)

---

## Завдання 1: Структури даних

**Файл:** `task1.py`

### Опис

Реалізація однозв'язного списку з основними операціями над ним.

### Реалізовано

#### ✅ Функція реверсування списку
- Змінює посилання між вузлами без створення нового списку
- Складність: O(n) за часом, O(1) за пам'яттю

#### ✅ Алгоритм сортування злиттям (Merge Sort)
- Ітеративна реалізація для однозв'язного списку
- Складність: O(n log n) за часом
- Стабільне сортування

#### ✅ Об'єднання двох відсортованих списків
- Злиття двох відсортованих списків в один відсортований
- Складність: O(n + m) за часом

### Запуск

```bash
uv run task1.py
```

### Приклад виводу

```
============================================================
ДЕМОНСТРАЦІЯ РОБОТИ З ОДНОЗВ'ЯЗНИМ СПИСКОМ
============================================================

1. Створення та виведення списку:
Початковий список:
5 -> 3 -> 8 -> 1 -> 9

2. Реверсування списку:
Реверсований список:
9 -> 1 -> 8 -> 3 -> 5

3. Сортування списку методом злиття:
Відсортований список:
1 -> 3 -> 5 -> 8 -> 9

4. Об'єднання двох відсортованих списків:
Перший список: 1 -> 3 -> 5
Другий список: 2 -> 4 -> 6
Об'єднаний відсортований список:
1 -> 2 -> 3 -> 4 -> 5 -> 6
```

---

## Завдання 2: Рекурсія. Дерево Піфагора

**Файл:** `task2.py`

### Опис

Візуалізація фрактала "Дерево Піфагора" за допомогою рекурсії та бібліотеки turtle.

### Реалізовано

#### ✅ Рекурсивна побудова фрактала
- Рекурсивний алгоритм побудови дерева
- Підтримка різних рівнів рекурсії

#### ✅ Інтерактивність
- Користувач може вказати рівень рекурсії
- Можливість задати кут розгалуження
- Можливість задати довжину гілок

#### ✅ Візуалізація
- Використання turtle для графіки
- Різні кольори для різних рівнів
- Плавний перехід кольорів

### Запуск

```bash
uv run task2.py
```

### Параметри

- **Рівень рекурсії:** визначає складність дерева (рекомендовано 5-10)
- **Довжина гілки:** початкова довжина гілки (за замовчуванням 100)
- **Кут:** кут розгалуження в градусах (за замовчуванням 30)

---

## Завдання 3: Алгоритм Дейкстри

**Файл:** `task3.py`

### Опис

Реалізація алгоритму Дейкстри для знаходження найкоротших шляхів у зваженому графі з використанням бінарної купи (піраміди) для оптимізації.

### Реалізовано

#### ✅ Алгоритм Дейкстри з бінарною купою
- Використання `heapq` (піраміда) для оптимізації вибору вершин
- Складність: O((V + E) log V)
- Знаходження найкоротших шляхів від початкової вершини до всіх інших

#### ✅ Граф
- Створення зваженого графа
- Підтримка неорієнтованих графів
- Візуалізація графа за допомогою NetworkX та Matplotlib

#### ✅ Візуалізація результатів
- Відображення графа з вагами ребер
- Виділення найкоротших шляхів
- Таблиця з відстанями до всіх вершин

### Запуск

```bash
uv run task3.py
```

### Приклад виводу

```
Найкоротші відстані від вершини A:
A -> A: 0
A -> B: 7
A -> C: 9
A -> D: 20
A -> E: 20
A -> F: 11
```

---

## Завдання 4: Візуалізація бінарної купи

**Файл:** `task4.py`

### Опис

Програма для візуалізації бінарної купи (heap) у вигляді дерева.

### Реалізовано

#### ✅ Візуалізація купи
- Перетворення масиву купи у бінарне дерево
- Візуалізація за допомогою NetworkX та Matplotlib
- Відображення значень вузлів

#### ✅ Підтримка різних типів куп
- Max-купа (максимальний елемент у корені)
- Min-купа (мінімальний елемент у корені)
- Довільна купа

### Запуск

```bash
uv run task4.py
```

### Приклад

Програма візуалізує різні типи куп:
- Дерево з завдання
- Max-купа: [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
- Min-купа: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

---

## Завдання 5: Візуалізація обходу дерева

**Файл:** `task5.py`

### Опис

Візуалізація обходів бінарного дерева в глибину (DFS) та в ширину (BFS) з використанням кольорового градієнта.

### Реалізовано

#### ✅ Обхід в глибину (DFS)
- Ітеративна реалізація з використанням стека
- БЕЗ рекурсії (згідно з вимогами)
- Pre-order обхід

#### ✅ Обхід в ширину (BFS)
- Реалізація з використанням черги (deque)
- Рівневий обхід дерева

#### ✅ Кольорова візуалізація
- Градієнт від темного (#1B1464) до світлого (#E8F4FF)
- Унікальний колір для кожного вузла
- Відображення порядку відвідування

#### ✅ Порівняння алгоритмів
- Наочна демонстрація різниці між DFS та BFS
- Виведення порядку відвідування вузлів

### Запуск

```bash
uv run task5.py
```

### Приклад виводу

```
Обхід дерева в глибину (DFS):
Порядок відвідування вузлів:
  1. Вузол 0 (колір: #1B1464)
  2. Вузол 4 (колір: #444083)
  3. Вузол 5 (колір: #6D6DA2)
  ...

Обхід дерева в ширину (BFS):
Порядок відвідування вузлів:
  1. Вузол 0 (колір: #1B1464)
  2. Вузол 4 (колір: #444083)
  3. Вузол 1 (колір: #6D6DA2)
  ...
```

---

## Завдання 6: Жадібні алгоритми та динамічне програмування

**Файл:** `task6.py`

### Опис

Розв'язання задачі вибору їжі з найбільшою сумарною калорійністю в межах обмеженого бюджету двома підходами.

### Реалізовано

#### ✅ Жадібний алгоритм
- Вибирає страви за найкращим співвідношенням калорій/вартість
- Швидкий, але не завжди оптимальний
- Складність: O(n log n)

#### ✅ Динамічне програмування
- Знаходить оптимальне рішення (Unbounded Knapsack)
- Гарантує максимальну калорійність
- Складність: O(n × W), де W — бюджет

#### ✅ Порівняння результатів
- Детальна таблиця з результатами обох методів
- Показує різницю в калорійності та вартості
- Тестування на різних бюджетах

### Запуск

```bash
uv run task6.py
```

### Доступні страви

| Страва     | Вартість | Калорії | Співвідношення |
|------------|----------|---------|----------------|
| pizza      | 50       | 300     | 6.00           |
| hamburger  | 40       | 250     | 6.25           |
| hot-dog    | 30       | 200     | 6.67           |
| pepsi      | 10       | 100     | 10.00          |
| cola       | 15       | 220     | 14.67          |
| potato     | 25       | 350     | 14.00          |

### Приклад виводу

```
ЖАДІБНИЙ АЛГОРИТМ
Бюджет: 100
Вибрані страви:
  cola: 6 шт. (вартість: 90, калорії: 1320)
  pepsi: 1 шт. (вартість: 10, калорії: 100)
Загальна калорійність: 1420

ДИНАМІЧНЕ ПРОГРАМУВАННЯ
Бюджет: 100
Вибрані страви:
  potato: 1 шт. (вартість: 25, калорії: 350)
  cola: 5 шт. (вартість: 75, калорії: 1100)
Загальна калорійність: 1450

✓ Динамічне програмування краще на 30 калорій (2.1%)
```

---

## Завдання 7: Метод Монте-Карло

**Файл:** `task7.py`

### Опис

Симуляція кидків двох кубиків методом Монте-Карло для визначення ймовірностей кожної можливої суми.

### Реалізовано

#### ✅ Симуляція методом Монте-Карло
- Імітація великої кількості кидків (до 1,000,000)
- Підрахунок частоти кожної суми (від 2 до 12)
- Обчислення емпіричних ймовірностей

#### ✅ Теоретичні розрахунки
- Таблиця з аналітичними ймовірностями
- Формули для кожної суми (кількість комбінацій / 36)

#### ✅ Візуалізація
- **Таблиця** з порівнянням симульованих та теоретичних ймовірностей
- **Графіки:**
  - Стовпчикова діаграма порівняння
  - Графік відхилень від теоретичних значень

#### ✅ Аналіз точності
- Розрахунок абсолютних та відносних відхилень
- Демонстрація закону великих чисел
- Тестування з різною кількістю кидків

### Запуск

```bash
uv run task7.py
```

### Теоретичні ймовірності

| Сума | Комбінацій | Ймовірність | Відсоток |
|------|------------|-------------|----------|
| 2    | 1/36       | 0.027778    | 2.78%    |
| 3    | 2/36       | 0.055556    | 5.56%    |
| 4    | 3/36       | 0.083333    | 8.33%    |
| 5    | 4/36       | 0.111111    | 11.11%   |
| 6    | 5/36       | 0.138889    | 13.89%   |
| 7    | 6/36       | 0.166667    | 16.67%   |
| 8    | 5/36       | 0.138889    | 13.89%   |
| 9    | 4/36       | 0.111111    | 11.11%   |
| 10   | 3/36       | 0.083333    | 8.33%    |
| 11   | 2/36       | 0.055556    | 5.56%    |
| 12   | 1/36       | 0.027778    | 2.78%    |

### Результати та висновки

#### Точність симуляції

Результати симуляції показують, що метод Монте-Карло дає точні наближення теоретичних ймовірностей. Точність залежить від кількості випробувань:

| Кількість кидків | Середнє відхилення |
|------------------|-------------------|
| 1,000            | 0.45%             |
| 10,000           | 0.24%             |
| 100,000          | 0.037%            |
| 1,000,000        | 0.023%            |

#### Порівняння з теоретичними значеннями

При 1,000,000 кидків отримано наступні результати:

| Сума | Монте-Карло | Теоретична | Відхилення |
|------|-------------|------------|------------|
| 2    | 2.78%       | 2.78%      | 0.006%     |
| 3    | 5.52%       | 5.56%      | 0.035%     |
| 4    | 8.35%       | 8.33%      | 0.014%     |
| 5    | 11.08%      | 11.11%     | 0.028%     |
| 6    | 13.95%      | 13.89%     | 0.062%     |
| 7    | 16.65%      | 16.67%     | 0.015%     |
| 8    | 13.93%      | 13.89%     | 0.038%     |
| 9    | 11.11%      | 11.11%     | 0.000%     |
| 10   | 8.29%       | 8.33%      | 0.043%     |
| 11   | 5.55%       | 5.56%      | 0.008%     |
| 12   | 2.79%       | 2.78%      | 0.010%     |

#### Висновки

1. **Закон великих чисел:** При збільшенні кількості експериментів емпіричні ймовірності наближаються до теоретичних. Це чітко видно з того, що середнє відхилення зменшується з 0.45% (1,000 кидків) до 0.023% (1,000,000 кидків).

2. **Точність методу:** При 1,000,000 кидків відхилення від теоретичних значень мінімальні (< 0.1% для всіх сум), що підтверджує високу точність методу Монте-Карло.

3. **Найімовірніша сума:** Як теоретично, так і експериментально, найімовірнішою сумою є **7** з ймовірністю близько 16.67%. Це логічно, оскільки існує найбільше комбінацій (6 з 36), що дають цю суму: (1,6), (2,5), (3,4), (4,3), (5,2), (6,1).

4. **Симетрія розподілу:** Розподіл ймовірностей симетричний відносно суми 7, що відповідає теоретичним очікуванням. Наприклад, P(2) = P(12), P(3) = P(11), P(4) = P(10) тощо.

5. **Практична застосовність:** Метод Монте-Карло є надійним інструментом для обчислення ймовірностей у випадках, коли аналітичні розрахунки складні або неможливі. Навіть при відносно невеликій кількості випробувань (10,000-100,000) можна отримати достатньо точні результати для практичних застосувань.

---

## Технічні вимоги

### Залежності

Всі залежності описані в `pyproject.toml`:

```toml
dependencies = [
    "pulp>=3.3.0",
    "networkx>=3.6.1",
    "matplotlib>=3.10.8",
]
```

### Встановлення

```bash
# Клонування репозиторію
git clone <repository-url>
cd goit-algo-fp

# Встановлення залежностей (використовуючи uv)
uv sync
```

### Запуск всіх завдань

```bash
# Послідовний запуск усіх завдань
uv run task1.py
uv run task2.py
uv run task3.py
uv run task4.py
uv run task5.py
uv run task6.py
uv run task7.py
```

## Стандарти коду

Всі завдання відповідають:
- ✅ **PEP 8** — стандарт стилю коду Python
- ✅ **Type Hints** — повна типізація всіх функцій
- ✅ **Docstrings** — документація українською мовою
- ✅ **Clean Code** — зрозумілі назви змінних та функцій

## Автор

Виконано в рамках курсу "Основи алгоритмів" GoIT.

## Ліцензія

Цей проект створено в навчальних цілях.
